本文是阅读完《深入浅出Java虚拟机》第2章、第7章、第8章、第12章结合并发课程
《Java核心技术》（卷Ⅰ）总结出来的  
 
 实例方法（非static方法）   Practical Java   JIT  GC     方法：调用者 接收者
 Class文件的编译过程   *.java->编译16进制.class->执行2进制     装箱类

第7章 虚拟机类加载机制 各种规范：Java虚拟机规范
    虚拟机HotSpot     命令行，p212
1.概述 p209/p232
    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终
    形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制
    C：编译时需要进行连接
    Java：运行期类加载
        用户可以通过Java预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络
        或其他地方加载一个二进制流作为程序代码的一部分。如Applet、JSP、OSGi，都使用了Java语言运行期类加载的特性
2.类加载的时机
    md插入图片
    解析、使用阶段的顺序不一定，动态绑定
    （1）初始化的规范
     ①4条字节码指令：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（final修饰除外）以及调用一个类的静态方法
     ②reflect包中的方法对类进行反射调用时，如果类没有进行过初始化
     ③略
     ④JVM启动时，要执行的主类（包含main()的类）会先初始化
     ⑤使用JDK1.7的动态语言支持，方法句柄
   上述5种，主动引用-》被动引用 看源码p211/p234
    ①通过子类引用父类的静态字段，不会导致子类初始化
    ②通过数组定义来引用类，不会触发此类的初始化
    ③引用该类的静态常量，不会触发此类的初始化
      注：常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
       常量传播优化
    （2）接口/类加载过程的区别
        接口中不能使用"static{}"语句块，但编译器仍然会为接口生成"<clinit>()"类构造器，用于初始化接口中所定义的成员变量。
        一个接口在初始化时，并不要求其父接口全部都完成了初始化，用到父接口是才会初始化
    
3.类加载的过程
    加载是Class Loading过程的一个阶段
    
    public final static int value = 123
    准备阶段将value赋值为123，那这个变量所使用的内存也会在方法区中进行分配吗？
    
    public static int value = 123
    准备阶段将value设置为int类型默认值0，初始化阶段赋值为123，在方法区分配内存
7.3.4解析 p243
7.4.类加载器
    （1）类与类加载器
        加载它的类加载器和这个类本身-》相等-》equals()、isAssignableFrom()、isInstance()、instanceof
    （2）双亲委派机制
        组合而非继承
        启动类加载器、拓展类加载器、应用程序类加载器(系统类加载器)  自定义类加载器   自定义类加载器
    
    tips:
        编写一个与rt.jar类库中已有类重名的Java类，可以正常编译，永远无法加载运行
    
    （3）破坏双亲委派模型
        线程类上下文加载器，OSGi、JNDI、JDBC、JCE、JAXB和JBI   
 
第8章 虚拟字节码执行引擎  
    1.概述
    
    物理机执行引擎-》处理器、硬件、指令集、操作系统 
    解释执行（解释器） 编译执行（即时编译器生成本地代码） 
2.运行时栈帧结构
    <img src = 'images/8-1.png'/>
    （1）局部变量表 
        变量槽 Variable Slot 32位以内
        long、double数据分割存储 ==》long、double的非原子性协定类似，Java内存模型
        内存优化，手动将其设置为null值 
    
    tips:
        局部变量没有赋予初始值不能使用，全局变量（类变量）无需赋予初始值（有准备阶段）
 
    （2）操作数栈
        算术运算，操作数栈来进行；调用其他方法，操作数栈来进行参数传递
        执行引擎-》基于（操作数）栈的执行引擎
    
    （3）动态连接
        静态解析-》类加载阶段、首次使用转化为直接引用
        动态连接-》每一次运行期间转化为直接引用
        
    （4）方法返回地址
        正常完成出口、异常完成出口

    （5）附加信息
        动态连接、方法返回地址、其他附加信息-》栈帧信息

3.方法调用
   （1）解析-》编译期可知，运行期不可变   
        静态方法、私有方法、实例构造器、父类方法、final方法
    
    （2）分派
        ①静态分派-》Overload  p247
            Overload-》编译器在重载时通过参数的静态类型而不是实际类型
            字面量没有显式的静态类型，如'com.junjun.demo.a'
      
    tips：
        char->int->long->float->double，可变长参数重载的优先级最低，没有byte、short
        Character不能转型成Integer
        
        ②动态分派-》Override  p251
            两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上
            
        ③单分派与多分派
            方法的宗量-》方法的接收者与方法的参数统称为
            唯一影响虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Son
            Java7是一门静态多分派、动态单分派的语言
            
        ④虚拟机动态分派的实现
            虚方法表 Vritual Method Table
            内联缓存 Inline Cache
            守护内联 Guarded Inlining
    
    (3)动态类型语言支持
    
Java里对象都在堆上，且对象只能通过引用访问，容器里放的其实是对象的引用而不是对象本身 
