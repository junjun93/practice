集合
   ArrayList
       set(), get(), add()2个, grow(), addAll(), remove(), size(), isEmpty()
       oldCapacity >> 1 相当于oldCapacity除以2
       int numMoved = size - index - 1;
       
   LinkedList
       add(E e), add(int index, E element), remove(), get(), set()
  
   消息通知：通过微信公众号通知功能来实现、我猜用netty

理想： 
面向对象、集合、IO、并发、NIO、Stream     lambda、函数式编程
数据库存储过程、视图、触发器、索引、优化、数据引擎
jsp
框架配置文件逐行解析
SpringBoot+SpringCloud+Netty+Shiro等等
前端html+css+js+npm+vue.js

  
Math类 LocalDate NumberFormat Date可变 p110 String、final不可变 
静态域/静态变量、实例域/全局变量、实例方法 参数变量、变量
编译器、解释器、执行器
第4章 对象和类    
    4.1面向对象程序设计概述   
        传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题  
        《算法+数据结构=程序》             
        OPP：首先要确定如何操作数据，然后再决定如何组织数据，以便于数据操作。    
        OOP：调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。  
        1.类 
            由类构造（construct）对象的过程称为创建类的实例（instance）
            对象中的数据称为实例域（instance field），操作数据的过程称为方法（method）
            通过拓展一个类来建立另外一个类的过程称为继承（inheritance）
        2.对象
        3.识别类
            识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词
        4.类之间的关系
            依赖、聚合、继承
            一个类的方法操纵另一个类的对象；一个Order对象包含一些Item对象
    4.2使用预定义类
        1.对象与对象变量
            构造器的名字应该与类名相同 new Date()
            对象与对象变量的区别 
                Date deadline;
                s = deadline.toString();
            一个对象变量并没有实际包含一个对象，而仅仅引用一个对象；显式地将对象变量设置为null，表明没有引用任何对象 示例代码回看 p97
            Java的对象变量看作C++的对象指针
        2.LocalDate类
            火星历 Calendrical Calculations
            不要使用构造器来构造LocalDate类的对象，应当使用静态工厂方法代表你调用构造器
        3.更改器方法、访问器方法/域访问器
            访问对象且修改对象的方法、访问对象不修改对象的方法
    4.3用户自定义类 少了笔记回看
        实例域、实例方法
        name域是String类对象，hireDay是LocalDate对象
        4.从构造器开始
            在构造类对象时，构造器会运行，以便将实例域初始化
            构造器与其他方法的不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器 p107
        5.隐式参数与显式参数
            方法用于操作对象以及读取它们的实例域
            关键字this表示隐式参数，也就是所构造的对象 -》区分实例域与局部变量 
        8.私有方法
            将所有的数据域都设置为私有的；某些情况下，将方法设置成私有的，私有方法不用就删
        9.final实例域
            基本类型域(primitive)、不可变类型域(immutable)
            final不可变的是对象引用，对象值爱变就变
    4.4静态域与静态方法
        1.静态域
            每个类中只有一个static类，每个对象有一个实例域的拷贝 回看对象引用的地址
            静态域：属于类，而不属于任何独立的对象
            实例域
        2.静态常量/静态变量
            private域+public final域都不能修改
            System.setOut方法是一个本地方法，可以绕过Java语言的存储控制机制，修改final变量的值
        3.静态方法
            静态方法是没有this参数的方法
            可以使用对象调用静态方法，容易造成混淆，建议使用类名 p114
        4.工厂方法
            LocalDate NumberFormat使用静态工厂方法来构造对象 p115疑问回看
    4.5方法参数
        按值调用(call by value)：方法不能修改变量值
        按引用调用(call by reference)：方法能修改变量值
        方法得到的是参数值的一个拷贝 p118方法测试
        方法参数的类型：基本数据类型、对象引用
        对象引用及其他的拷贝同时引用同一个对象，Java对对象采用的是值调用 p119、p120倒数5行
    4.6对象构造
        重载(overloading)、重载解析(overloading resolution)
        方法名+参数类型=方法的签名(signature)，返回值不是方法的签名，名参相同返不同是同一个方法，同时写在一个类文件里会报错
        实例域自动初始化为默认值、局部变量不行
        类没写构造器，系统会提供一个参数的构造器，反之不提供  查看编译后的代码
        初始值不一定是常量值 p125回看
        7.初始化块
            在构造器中设置值、在声明中设置值、初始化块(initialization block)
            先运行初始化块，才运行构造器；通常会直接将初始化代码放在构造器中
            使用静态的初始化块初始化静态域
        8.对象析构与finalize方法
            Java不支持析构器，finalize方法将在垃圾回收器清除对象之前调用；对象用完，使用close方法清理内存
    4.7包
    
第5章 继承
    5.1类、超类和子类
        通用的方法放在超类中，特殊的方法放在子类中
        子类不能直接访问父类隐藏域，必须调用父类的公有方法
        super.getSalary(); //编译后的代码 p149
        super不是一个对象的引用，指示编译器调用超类方法的特殊关键字
        super调用构造器的句子必须是子类构造器的第一条语句
    
tips：this与super
    this：引用隐式参数、调用该类其他的构造器
    super：调用超类的方法、调用超类的构造器
        一个对象变量可以指示多种实际类型的现象被称为多态(polymorphism)，在运行时能够自动地选择调用哪个方法的现象称为动态绑定(dynamic binding)
    4.继承层次
        继承层次、继承链 p153
    5.多态
        is-a规则 <=> 置换法则
        对象变量是多态的，引用自身对象+子类对象；子类变量不能引用超类
    6.理解方法调用 p155
        编译器、重载解析
        允许子类将覆盖方法的返回类型定义为原返回类型的子类型
        private、static、final方法调用-》静态绑定(static binding)
        方法表(method table)
        动态绑定无需对现存的代码进行修改，就可以对程序进行拓展
        在覆盖一个方法的时候，子类方法不能低于超类方法的可见性
    7.阻止继承：final类和方法
        不允许拓展的类被称为final类
        final域，构造对象之后就不允许改变他们的值了；类声明为final，方法自动变成final，而不包括域  如：Calendar final String
        内联(inlining)    即时编译器、传统编译器
    8.强制类型转换
        数值、对象引用
        超类变子类前，instanceof进行检查
        少用类型转换和instanceof运算符
    9.抽象类
        提高程序清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的
        p161 ？？抽象类、抽象方法区别+源码实例
        抽象对象创建数组也用new≠创建对象
